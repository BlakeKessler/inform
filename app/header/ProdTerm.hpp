// A class representing a "product term" (conjunction of literals)
// It uses two bitmasks
//   1. `_mask`, representing which variables are part of the term
//   2. `_vals`, representing the truth values of the variables that are part of the term
// There is one special case with two variants.
// When `_mask == 0` (all variables masked out), the term either represents a tautology or a contradiction
//   1. `_vals == 0` → the term is a tautology
//   2. `_vals != 0` → the term is a contradiction
// Random ProdTerm objects are generated by generating two 32-bit integers, using one as the mask, and the other as the values.
// If more variables are needed in the proofs, larger integer types can be used
//  * a simple find-and-replace could be used on all files in the `app` directory to replace all `uint64` with `uint128`, then replace all `uint32` with `uint64`, which would double the number of available variables
//  * if more variables than that are required, any in-place big integer class that overloads the bitwise operators and boolean typecast appropriately should be a drop-in replacement

#ifndef INFORM_PROD_TERM_HPP
#define INFORM_PROD_TERM_HPP

#include "inform.hpp"
#include <bit>

//!product term
struct alignas(uint64) inform::ProdTerm {
   public:
      enum Status : ubyte {
         FALSE = false,
         TRUE = true,
         NULL
      };

   private:
      uint32 _vals; //value of variables
      uint32 _mask; //which variables are actually part of the term
      //!_mask -> (_vals ? CONTRADICTION : TAUTOLOGY)
      ProdTerm(uint32 vars = 0, uint32 mask = 0):_vals{vars},_mask{mask} {}
   public:
      static ProdTerm make(uint32 vars = 0, uint32 mask = 0) { return {mask ? vars & mask : vars, mask}; }
      static ProdTerm makeContradiction() { return {~0u, 0}; }
      static ProdTerm makeTautology() { return {0, 0}; }
      static ProdTerm makeRand(uint maxVars, uint sparsity);
      ProdTerm copy() const { return self; }

      uint32 vals() const { return _vals; }
      uint32 mask() const { return _mask; }

      uint32 trueMask() const { return _vals & _mask; }
      uint32 falseMask() const { return (~_vals) & _mask; }

      uint64 toInt() const { return std::bit_cast<uint64>(self); }

      Status operator[](ubyte i) const;

      ProdTerm& operator&=(const ProdTerm& other);
      ProdTerm operator&(const ProdTerm& other) const { return copy() &= other; }
      SopExpr operator|(const ProdTerm& other) const;

      bool isContradiction() const;
      bool isTautology() const;

      bool operator==(const ProdTerm& other) const;
      bool subsumes(const ProdTerm& other) const;

};

namespace mcsl {
   uint writef(File&, const inform::ProdTerm&, char, FmtArgs);
};

#endif